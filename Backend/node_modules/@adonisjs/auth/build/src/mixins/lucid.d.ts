import type { Hash } from '@adonisjs/core/hash';
import { type BaseModel } from '@adonisjs/lucid/orm';
import type { NormalizeConstructor } from '@adonisjs/core/types/helpers';
/**
 * Mixing to add user lookup and password verification methods
 * on a model.
 *
 * Under the hood, this mixin defines following methods and hooks
 *
 * - beforeSave hook to hash user password
 * - findForAuth method to find a user during authentication
 * - verifyCredentials method to verify user credentials and prevent
 *   timing attacks.
 */
export declare function withAuthFinder(hash: () => Hash, options: {
    uids: string[];
    passwordColumnName: string;
}): <Model extends NormalizeConstructor<typeof BaseModel>>(superclass: Model) => {
    new (...args: any[]): {
        $attributes: import("@adonisjs/lucid/types/model").ModelObject;
        $extras: import("@adonisjs/lucid/types/model").ModelObject;
        $original: import("@adonisjs/lucid/types/model").ModelObject;
        $preloaded: {
            [relation: string]: import("@adonisjs/lucid/types/model").LucidRow | import("@adonisjs/lucid/types/model").LucidRow[];
        };
        $columns: undefined;
        $sideloaded: import("@adonisjs/lucid/types/model").ModelObject;
        $primaryKeyValue?: number | string;
        $isPersisted: boolean;
        $isNew: boolean;
        $isLocal: boolean;
        $dirty: import("@adonisjs/lucid/types/model").ModelObject;
        $isDirty: boolean;
        $isDeleted: boolean;
        $options?: import("@adonisjs/lucid/types/model").ModelOptions;
        $trx?: import("@adonisjs/lucid/types/database").TransactionClientContract;
        $setOptionsAndTrx(options?: import("@adonisjs/lucid/types/model").ModelAdapterOptions): void;
        useTransaction(trx: import("@adonisjs/lucid/types/database").TransactionClientContract): any;
        useConnection(connection: string): any;
        $getQueryFor(action: "insert", client: import("@adonisjs/lucid/types/database").QueryClientContract): ReturnType<import("@adonisjs/lucid/types/database").QueryClientContract["insertQuery"]>;
        $getQueryFor(action: "update" | "delete" | "refresh", client: import("@adonisjs/lucid/types/database").QueryClientContract): import("@adonisjs/lucid/types/model").ModelQueryBuilderContract<import("@adonisjs/lucid/types/model").LucidModel>;
        $setAttribute(key: string, value: any): void;
        $getAttribute(key: string): any;
        $getAttributeFromCache(key: string, callback: import("@adonisjs/lucid/types/model").CacheNode["getter"]): any;
        $hasRelated(key: string): boolean;
        $setRelated(key: string, result: import("@adonisjs/lucid/types/querybuilder").OneOrMany<import("@adonisjs/lucid/types/model").LucidRow> | null): void;
        $pushRelated(key: string, result: import("@adonisjs/lucid/types/querybuilder").OneOrMany<import("@adonisjs/lucid/types/model").LucidRow> | null): void;
        $getRelated(key: string, defaultValue?: any): import("@adonisjs/lucid/types/querybuilder").OneOrMany<import("@adonisjs/lucid/types/model").LucidRow> | undefined | null;
        $consumeAdapterResult(adapterResult: import("@adonisjs/lucid/types/model").ModelObject, sideloadAttributes?: import("@adonisjs/lucid/types/model").ModelObject): void;
        $hydrateOriginals(): void;
        fill(value: Partial<{}>, allowExtraProperties?: boolean): any;
        merge(value: Partial<{}>, allowExtraProperties?: boolean): any;
        enableForceUpdate(): any;
        save(): Promise<any>;
        lockForUpdate<T>(callback: (user: any) => T | Promise<T>): Promise<T>;
        delete(): Promise<void>;
        refresh(): Promise<any>;
        load: import("@adonisjs/lucid/types/model").LucidRowPreload<any>;
        loadOnce: import("@adonisjs/lucid/types/model").LucidRowPreloadOnce<any>;
        preload: import("@adonisjs/lucid/types/model").LucidRowPreload<any>;
        loadAggregate: <Self extends any, Name extends import("@adonisjs/lucid/types/relations").ExtractModelRelations<Self>, RelatedBuilder = Self[Name] extends import("@adonisjs/lucid/types/relations").ModelRelations<import("@adonisjs/lucid/types/model").LucidModel, import("@adonisjs/lucid/types/model").LucidModel> ? Self[Name]["subQuery"] : never>(name: Name, callback: (builder: RelatedBuilder) => void) => import("@adonisjs/lucid/types/model").LazyLoadAggregatesContract<Self>;
        loadCount: <Self extends any, Name_1 extends import("@adonisjs/lucid/types/relations").ExtractModelRelations<Self>, RelatedBuilder_1 = Self[Name_1] extends import("@adonisjs/lucid/types/relations").ModelRelations<import("@adonisjs/lucid/types/model").LucidModel, import("@adonisjs/lucid/types/model").LucidModel> ? Self[Name_1]["subQuery"] : never>(name: Name_1, callback?: ((builder: RelatedBuilder_1) => void) | undefined) => import("@adonisjs/lucid/types/model").LazyLoadAggregatesContract<Self>;
        serializeAttributes(fields?: import("@adonisjs/lucid/types/model").CherryPickFields, raw?: boolean): import("@adonisjs/lucid/types/model").ModelObject;
        serializeComputed(fields?: import("@adonisjs/lucid/types/model").CherryPickFields): import("@adonisjs/lucid/types/model").ModelObject;
        serializeRelations(fields: undefined, raw: true): {
            [key: string]: import("@adonisjs/lucid/types/model").LucidRow | import("@adonisjs/lucid/types/model").LucidRow[];
        };
        serializeRelations(cherryPick: import("@adonisjs/lucid/types/model").CherryPick["relations"] | undefined, raw: false | undefined): import("@adonisjs/lucid/types/model").ModelObject;
        serializeRelations(cherryPick?: import("@adonisjs/lucid/types/model").CherryPick["relations"], raw?: boolean): import("@adonisjs/lucid/types/model").ModelObject;
        serialize(cherryPick?: import("@adonisjs/lucid/types/model").CherryPick): import("@adonisjs/lucid/types/model").ModelObject;
        toObject(): import("@adonisjs/lucid/types/model").ModelObject;
        toJSON(): import("@adonisjs/lucid/types/model").ModelObject;
        related<Name_2 extends undefined>(relation: Name_2): any[Name_2] extends import("@adonisjs/lucid/types/relations").ModelRelations<import("@adonisjs/lucid/types/model").LucidModel, import("@adonisjs/lucid/types/model").LucidModel> ? any[Name_2]["client"] : never;
    };
    /**
     * Hook to verify user password when creating or updating
     * the user model.
     */
    hashPassword<T extends any & Model>(this: T, user: InstanceType<T>): Promise<void>;
    /**
     * Finds the user for authentication via "verifyCredentials".
     * Feel free to override this method customize the user
     * lookup behavior.
     */
    findForAuth<T extends any & Model>(this: T, uids: string[], value: string): Promise<InstanceType<T> | null>;
    /**
     * Find a user by uid and verify their password. This method is
     * safe from timing attacks.
     */
    verifyCredentials<T extends any & Model>(this: T, uid: string, password: string): Promise<InstanceType<T>>;
    readonly booted: boolean;
    find: <T extends import("@adonisjs/lucid/types/model").LucidModel>(this: T, value: any, options?: import("@adonisjs/lucid/types/model").ModelAdapterOptions) => Promise<null | InstanceType<T>>;
    $columnsDefinitions: Map<string, import("@adonisjs/lucid/types/model").ModelColumnOptions>;
    $relationsDefinitions: Map<string, import("@adonisjs/lucid/types/relations").RelationshipsContract>;
    $computedDefinitions: Map<string, import("@adonisjs/lucid/types/model").ComputedOptions>;
    primaryKey: string;
    connection?: string | undefined;
    namingStrategy: import("@adonisjs/lucid/types/model").NamingStrategyContract;
    table: string;
    selfAssignPrimaryKey: boolean;
    $adapter: import("@adonisjs/lucid/types/model").AdapterContract;
    useAdapter: (adapter: import("@adonisjs/lucid/types/model").AdapterContract) => void;
    $hooks: import("@poppinss/hooks").default<any>;
    $keys: {
        attributesToColumns: import("@adonisjs/lucid/types/model").ModelKeysContract;
        attributesToSerialized: import("@adonisjs/lucid/types/model").ModelKeysContract;
        columnsToAttributes: import("@adonisjs/lucid/types/model").ModelKeysContract;
        columnsToSerialized: import("@adonisjs/lucid/types/model").ModelKeysContract;
        serializedToColumns: import("@adonisjs/lucid/types/model").ModelKeysContract;
        serializedToAttributes: import("@adonisjs/lucid/types/model").ModelKeysContract;
    };
    $createFromAdapterResult: <T extends import("@adonisjs/lucid/types/model").LucidModel>(this: T, result?: import("@adonisjs/lucid/types/model").ModelObject, sideloadAttributes?: import("@adonisjs/lucid/types/model").ModelObject, options?: import("@adonisjs/lucid/types/model").ModelAdapterOptions) => null | InstanceType<T>;
    $createMultipleFromAdapterResult: <T extends import("@adonisjs/lucid/types/model").LucidModel>(this: T, results: import("@adonisjs/lucid/types/model").ModelObject[], sideloadAttributes?: import("@adonisjs/lucid/types/model").ModelObject, options?: import("@adonisjs/lucid/types/model").ModelAdapterOptions) => InstanceType<T>[];
    $addColumn: (name: string, options: Partial<import("@adonisjs/lucid/types/model").ColumnOptions>) => import("@adonisjs/lucid/types/model").ColumnOptions;
    $hasColumn: (name: string) => boolean;
    $getColumn: (name: string) => import("@adonisjs/lucid/types/model").ModelColumnOptions | undefined;
    $addComputed: (name: string, options: Partial<import("@adonisjs/lucid/types/model").ComputedOptions>) => import("@adonisjs/lucid/types/model").ComputedOptions;
    $hasComputed: (name: string) => boolean;
    $getComputed: (name: string) => import("@adonisjs/lucid/types/model").ComputedOptions | undefined;
    $addRelation: (name: string, type: import("@adonisjs/lucid/types/relations").ModelRelationTypes["__opaque_type"], relatedModel: () => import("@adonisjs/lucid/types/model").LucidModel, options: import("@adonisjs/lucid/types/model").ModelRelationOptions) => void;
    $hasRelation: (name: string) => boolean;
    $getRelation: {
        <Model_1 extends import("@adonisjs/lucid/types/model").LucidModel, Name_2 extends import("@adonisjs/lucid/types/relations").ExtractModelRelations<InstanceType<Model_1>>>(this: Model_1, name: Name_2): InstanceType<Model_1>[Name_2] extends import("@adonisjs/lucid/types/relations").ModelRelations<import("@adonisjs/lucid/types/model").LucidModel, import("@adonisjs/lucid/types/model").LucidModel> ? InstanceType<Model_1>[Name_2]["client"]["relation"] : import("@adonisjs/lucid/types/relations").RelationshipsContract;
        <Model_1 extends import("@adonisjs/lucid/types/model").LucidModel>(this: Model_1, name: string): import("@adonisjs/lucid/types/relations").RelationshipsContract;
    };
    $defineProperty: <Model_1 extends import("@adonisjs/lucid/types/model").LucidModel, Prop extends keyof Model_1>(this: Model_1, propertyName: Prop, defaultValue: Model_1[Prop], strategy: "inherit" | "define" | ((value: Model_1[Prop]) => Model_1[Prop])) => void;
    boot: () => void;
    before: {
        <Model_1 extends import("@adonisjs/lucid/types/model").LucidModel, Event extends "find" | "fetch">(this: Model_1, event: Event, handler: import("@adonisjs/lucid/types/model").HooksHandler<import("@adonisjs/lucid/types/model").ModelQueryBuilderContract<Model_1>, Event>): void;
        <Model_1 extends import("@adonisjs/lucid/types/model").LucidModel>(this: Model_1, event: "paginate", handler: import("@adonisjs/lucid/types/model").HooksHandler<[import("@adonisjs/lucid/types/model").ModelQueryBuilderContract<Model_1>, import("@adonisjs/lucid/types/model").ModelQueryBuilderContract<Model_1>], "paginate">): void;
        <Model_1 extends import("@adonisjs/lucid/types/model").LucidModel, Event_1 extends import("@adonisjs/lucid/types/model").EventsList>(this: Model_1, event: Event_1, handler: import("@adonisjs/lucid/types/model").HooksHandler<InstanceType<Model_1>, Event_1>): void;
    };
    after: {
        <Model_1 extends import("@adonisjs/lucid/types/model").LucidModel>(this: Model_1, event: "fetch", handler: import("@adonisjs/lucid/types/model").HooksHandler<InstanceType<Model_1>[], "fetch">): void;
        <Model_1 extends import("@adonisjs/lucid/types/model").LucidModel>(this: Model_1, event: "paginate", handler: import("@adonisjs/lucid/types/model").HooksHandler<import("@adonisjs/lucid/types/model").ModelPaginatorContract<InstanceType<Model_1>>, "paginate">): void;
        <Model_1 extends import("@adonisjs/lucid/types/model").LucidModel, Event_2 extends import("@adonisjs/lucid/types/model").EventsList>(this: Model_1, event: Event_2, handler: import("@adonisjs/lucid/types/model").HooksHandler<InstanceType<Model_1>, Event_2>): void;
    };
    create: <T extends import("@adonisjs/lucid/types/model").LucidModel>(this: T, values: Partial<import("@adonisjs/lucid/types/model").ModelAttributes<InstanceType<T>>>, options?: import("@adonisjs/lucid/types/model").ModelAssignOptions) => Promise<InstanceType<T>>;
    createMany: <T extends import("@adonisjs/lucid/types/model").LucidModel>(this: T, values: Partial<import("@adonisjs/lucid/types/model").ModelAttributes<InstanceType<T>>>[], options?: import("@adonisjs/lucid/types/model").ModelAssignOptions) => Promise<InstanceType<T>[]>;
    findOrFail: <T extends import("@adonisjs/lucid/types/model").LucidModel>(this: T, value: any, options?: import("@adonisjs/lucid/types/model").ModelAdapterOptions) => Promise<InstanceType<T>>;
    findBy: {
        <T extends import("@adonisjs/lucid/types/model").LucidModel>(this: T, clause: Record<string, unknown>, options?: import("@adonisjs/lucid/types/model").ModelAdapterOptions): Promise<null | InstanceType<T>>;
        <T extends import("@adonisjs/lucid/types/model").LucidModel>(this: T, key: string, value: any, options?: import("@adonisjs/lucid/types/model").ModelAdapterOptions): Promise<null | InstanceType<T>>;
    };
    findByOrFail: {
        <T extends import("@adonisjs/lucid/types/model").LucidModel>(this: T, clause: Record<string, unknown>, options?: import("@adonisjs/lucid/types/model").ModelAdapterOptions): Promise<InstanceType<T>>;
        <T extends import("@adonisjs/lucid/types/model").LucidModel>(this: T, key: string, value: any, options?: import("@adonisjs/lucid/types/model").ModelAdapterOptions): Promise<InstanceType<T>>;
    };
    findManyBy: {
        <T extends import("@adonisjs/lucid/types/model").LucidModel>(this: T, clause: Record<string, unknown>, options?: import("@adonisjs/lucid/types/model").ModelAdapterOptions): Promise<InstanceType<T>[]>;
        <T extends import("@adonisjs/lucid/types/model").LucidModel>(this: T, key: string, value: any, options?: import("@adonisjs/lucid/types/model").ModelAdapterOptions): Promise<InstanceType<T>[]>;
    };
    first: <T extends import("@adonisjs/lucid/types/model").LucidModel>(this: T, options?: import("@adonisjs/lucid/types/model").ModelAdapterOptions) => Promise<null | InstanceType<T>>;
    firstOrFail: <T extends import("@adonisjs/lucid/types/model").LucidModel>(this: T, options?: import("@adonisjs/lucid/types/model").ModelAdapterOptions) => Promise<InstanceType<T>>;
    findMany: <T extends import("@adonisjs/lucid/types/model").LucidModel>(this: T, value: any[], options?: import("@adonisjs/lucid/types/model").ModelAdapterOptions) => Promise<InstanceType<T>[]>;
    firstOrNew: <T extends import("@adonisjs/lucid/types/model").LucidModel>(this: T, searchPayload: Partial<import("@adonisjs/lucid/types/model").ModelAttributes<InstanceType<T>>>, savePayload?: Partial<import("@adonisjs/lucid/types/model").ModelAttributes<InstanceType<T>>>, options?: import("@adonisjs/lucid/types/model").ModelAssignOptions) => Promise<InstanceType<T>>;
    firstOrCreate: <T extends import("@adonisjs/lucid/types/model").LucidModel>(this: T, searchPayload: Partial<import("@adonisjs/lucid/types/model").ModelAttributes<InstanceType<T>>>, savePayload?: Partial<import("@adonisjs/lucid/types/model").ModelAttributes<InstanceType<T>>>, options?: import("@adonisjs/lucid/types/model").ModelAssignOptions) => Promise<InstanceType<T>>;
    updateOrCreate: <T extends import("@adonisjs/lucid/types/model").LucidModel>(this: T, searchPayload: Partial<import("@adonisjs/lucid/types/model").ModelAttributes<InstanceType<T>>>, updatePayload: Partial<import("@adonisjs/lucid/types/model").ModelAttributes<InstanceType<T>>>, options?: import("@adonisjs/lucid/types/model").ModelAssignOptions) => Promise<InstanceType<T>>;
    fetchOrNewUpMany: <T extends import("@adonisjs/lucid/types/model").LucidModel>(this: T, predicate: keyof import("@adonisjs/lucid/types/model").ModelAttributes<InstanceType<T>> | (keyof import("@adonisjs/lucid/types/model").ModelAttributes<InstanceType<T>>)[], payload: Partial<import("@adonisjs/lucid/types/model").ModelAttributes<InstanceType<T>>>[], options?: import("@adonisjs/lucid/types/model").ModelAssignOptions) => Promise<InstanceType<T>[]>;
    fetchOrCreateMany: <T extends import("@adonisjs/lucid/types/model").LucidModel>(this: T, predicate: keyof import("@adonisjs/lucid/types/model").ModelAttributes<InstanceType<T>> | (keyof import("@adonisjs/lucid/types/model").ModelAttributes<InstanceType<T>>)[], payload: Partial<import("@adonisjs/lucid/types/model").ModelAttributes<InstanceType<T>>>[], options?: import("@adonisjs/lucid/types/model").ModelAssignOptions) => Promise<InstanceType<T>[]>;
    updateOrCreateMany: <T extends import("@adonisjs/lucid/types/model").LucidModel>(this: T, predicate: keyof import("@adonisjs/lucid/types/model").ModelAttributes<InstanceType<T>> | (keyof import("@adonisjs/lucid/types/model").ModelAttributes<InstanceType<T>>)[], payload: Partial<import("@adonisjs/lucid/types/model").ModelAttributes<InstanceType<T>>>[], options?: import("@adonisjs/lucid/types/model").ModelAssignOptions) => Promise<InstanceType<T>[]>;
    all: <T extends import("@adonisjs/lucid/types/model").LucidModel>(this: T, options?: import("@adonisjs/lucid/types/model").ModelAdapterOptions) => Promise<InstanceType<T>[]>;
    query: <Model_1 extends import("@adonisjs/lucid/types/model").LucidModel, Result = InstanceType<Model_1>>(this: Model_1, options?: import("@adonisjs/lucid/types/model").ModelAdapterOptions) => import("@adonisjs/lucid/types/model").ModelQueryBuilderContract<Model_1, Result>;
    truncate: (cascade?: boolean) => Promise<void>;
} & Model;
